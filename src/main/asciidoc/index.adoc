= Accessing Data via REST
Greg Turnquist; Roy Clarkson
:doctype: book
:toc:
:toclevels: 4
:source-highlighter: highlightjs
:spring-data-rest-version: 2.3.0.RELEASE

[[intro]]
== Introduction

This showcase application demonstrates the power of Spring Data REST on multiple fronts.

* Simple domain model with multiple relationships
* Automatically generated and tailored hypermedia
* No code to link frontend hypermedia with backend domain model
* Little code to add custom Spring MVC endpoints
* http://docs.spring.io/spring-data/rest/docs/{spring-data-rest-version}/reference/html/#projections-excerpts[Projections and exercepts]
to filter JSON responses
* Excluded fields for security purposes
* Event-driven operations
* Spring Data REST as used in a Spring Boot configuration

[[domain-model]]
== Digging into the domain model

This section contains details about how to interact with the domain model.

[[domain-model.items]]
=== Items

Items are images that can be uploaded. Spring-a-Gram allows you to pick pictures from your desktop or snap a picture on your phone.

The following code shows some basic interactions with *Item* entities that map onto the *ITEMS* table on the backend.

You can fetch a collection of items with no image data like this:

include::{generated}/getCollectionOfItemsWithNoImages/curl-request.adoc[]

In this request, the *projection* parameter is applied with the value of *noImages*. This projection, i.e. filter, is defined with this
interface:

.src/main/java/com/greglturnquist/springagram/NoImages.java
====
[source,java]
----
include::{baseDir}/src/main/java/com/greglturnquist/springagram/NoImages.java[tag=projection]
----
====

http://docs.spring.io/spring-data/rest/docs/{spring-data-rest-version}/reference/html/#projections-excerpts[Projections] provide a way to
alter the JSON response served by the backend. In this case, the only getter method is for the `htmlUrl` attribute of
the `Item` class. Any other fields are discarded before building up the response.

The response is a HAL-based document like this:

.HAL-based response with a collection of items
====
include::{generated}/getCollectionOfItemsWithNoImages/http-response.adoc[]
====

In this output, the image data isn't displayed as expected.

[NOTE]
====
Why discard image data? This allows clients, mobile ones in particular, to retrieve a collection of URIs quickly and
without consuming a lot of bandwdith. Fetching individual images can be delegated to a promise-based, async solution. This
application uses https://github.com/cujojs/rest[rest.js] as follows:

.src/main/resources/static/app/main.js
[source,javascript,indent=0]
----
include::{baseDir}/src/main/resources/static/app/main.js[tag=find-unlinked-images]
----

This block shows multiple hops, some with filters, followed by an asyc callback to retrieve each image individually. Once
all are complete, the code moves on.
====

==== Creating a new item

Creating new resources involves POST'ing on the collection's resource endpoint. Through hypermedia, you can start at the
root node and hop to the appropriate colection quickly. Assuming you did that, the following shows an example of submitting
new content and seeing the results.

include::{generated}/createAndDestroy.create/curl-request.adoc[]

This cURL request mentioned nothing about an id, a gallery, nor the HTML URL, attributes you've seen in other parts of
this document.

* *id* is an internal value. In this situation, it's the primary key in a relational table. But such data should remain
server side and not be a part of the client's workings.
* *gallery* is not a required attribute, so in this situation, we chose to not link it.
* *htmlUrl* is a read-only field. It is generated by linking to a fixed Spring MVC controller in the following method:

[source,java]
----
public class Item {
	...
include::{baseDir}/src/main/java/com/greglturnquist/springagram/Item.java[tag=html-url]
	...
----

We can see the results below:

include::{generated}/createAndDestroy.create/http-response.adoc[]

* The HTTP status code was *201 Created*.
* Spring Data REST provides a *Location* header with the URI of the newly created resource.
* For convenience, it also returns a HAL representation in the body.

Deleting resources is simple:

include::{generated}/createAndDestroy.delete/curl-request.adoc[]

====
include::{generated}/createAndDestroy.delete/http-response.adoc[]
====

If we check that resource URI again, it should be gone:

include::{generated}/createAndDestroy.recheck/curl-request.adoc[]

====
include::{generated}/createAndDestroy.recheck/http-response.adoc[]
====


[[domain-model.galleries]]
=== Galleries

`Gallery` is linked to `Item` through a one-to-many relationship. This is defined in the domain model with a simple JPA relationship.

`Item` defines it like this:

.src/main/java/com/greglturnquist/springagram/Item.java
====
[source,java]
----
public class Item {
	...
include::{baseDir}/src/main/java/com/greglturnquist/springagram/Item.java[tag=gallery-def]
	...
----
====

And `Gallery` defines the other side like this:

.src/main/java/com/greglturnquist/springagram/Gallery.java
====
[source,java,indent=0]
----
public class Gallery {
	...
include::{baseDir}/src/main/java/com/greglturnquist/springagram/Gallery.java[tag=items-def]
	...
----
====

NOTE: `mappedBy = "gallery"` indicates `Item.gallery` holds the foreign key in the relational tables.

With this in place, we can easily query for a list of all galleries:

include::{generated}/getCollectionOfGalleries/curl-request.adoc[]

And with that, we can see this response:

.HAL-based response with a collection of galleries
====
include::{generated}/getCollectionOfGalleries/http-response.adoc[]
====

[[hopping]]
== Hopping from node to node

One of the most powerful concepts of the web is the ability to link different parts together. Hypermedia-based APIs
provide a similar mechanism to serve up data as well as related links. This makes it much easier to decouple clients
from the server-side backend. Instead of hard coding URIs into the client, instead navigate by relationship. The
following chain of operations shows how to start at the base URI for the API and navigate to a specific record by
relationships.

First, start at the root of the API. This is URI that you MUST code into the client.

include::{generated}/hoppingFromRootToSingleItem.root/curl-request.adoc[]

====
include::{generated}/hoppingFromRootToSingleItem.root/http-response.adoc[]
====

From here, your client should look for *"items*", grab the `href`, and navigate to it. In this scenario, we are filtering
out the image data by applying a projection.

include::{generated}/hoppingFromRootToSingleItem.items/curl-request.adoc[]

====
include::{generated}/hoppingFromRootToSingleItem.items/http-response.adoc[]
====

The *_embedded* portion of this response gives us a quick snapshot view. But we are instead looking for a custom finder
method that retrieves only items that are not linked to a gallery. To do that, look up *"search"*.

include::{generated}/hoppingFromRootToSingleItem.search/curl-request.adoc[]

====
include::{generated}/hoppingFromRootToSingleItem.search/http-response.adoc[]
====

This repository only has one finder, *"findByGalleryIsNull"*. Grab it and go (again with the filter turned on).

include::{generated}/hoppingFromRootToSingleItem.findByGalleryIsNull/curl-request.adoc[]

====
include::{generated}/hoppingFromRootToSingleItem.findByGalleryIsNull/http-response.adoc[]
====

We get another collection, denoted by *"_embedded"*. From here, our client can iterate over entry, fetching every *"self"*
URI without the filter.

include::{generated}/hoppingFromRootToSingleItem/api/items/1/curl-request.adoc[]

====
include::{generated}/hoppingFromRootToSingleItem/api/items/1/http-response.adoc[]
====

At no time did our client have to know the URI of any of these resources. The client also avoided constructing URIs. This
is a common problem when primary keys are exposed. Clients will take a shortcut and assemble the URI based on existing
patterns. The risk is that the URIs become brittle and hard to change without breaking clients. Instead, depending on
relationships is more flexible.

[[security]]
== Security

"It's not real until it's secured."
-- Greg Turnquist, DevNexus 2015

A common pattern when securing your application is to define key domain objects to manage user data. In this app, items
are owned by users. To represent this, `Item` has a `User` attribute.

[source,java]
----
public class Item {
	....
	@OneToOne
	private User user
	....
----

This makes it easy to associate items with users. To make it super simple to manage users, this application has a repository
plugged into its Spring Security configuration, leveraging Spring Data JPA's CRUD operations. The problem is that by
default, Spring Data REST will export that repository and let anyone see user details including passwords. It even lets
people manipulate the data. A couple declarative annotations are all that it takes to secure everything properly.

For starters, the *user* attribute up above needs to be prevented from appearing in any JSON representatio of an item
This not only avoids giving out details, but also blocks updates. In the fragment below, the `@JsonIgnore`
annotation prevents this field from ever appearing, now matter how an `Item` appears.

[source,java]
----
public class Item {
	...
include::{baseDir}/src/main/java/com/greglturnquist/springagram/Item.java[tag=user-def]
	...
----

NOTE: This works whether you are rendering an `Item` directly, or if `Item` is being pulled in by relationship on another
domain object.

That takes care of hiding the user data on items. You also need to flat out NOT export the `User`-based repository.

[source,java]
----
include::{baseDir}/src/main/java/com/greglturnquist/springagram/UserRepository.java[tag=user-repository]
----

The `@RepositoryRestResource(exported = false)` annotation prevents this repository from being exposed by Spring
Data REST.

There is a third level of security to apply that isn't so obvious: protecting passwords at all costs. We'll see how in
the following scenario.

There are times when the client needs to know the owner of an item. In that situation, we write a projection that ADDS
the `User` data back in, compared to the filter we wrote earlier.

[source,java]
----
include::{baseDir}/src/main/java/com/greglturnquist/springagram/Owner.java[tag=owner]
----

This projection adds the `getUser()` getter but without the `@JsonIgnore` annotation. This overrides any Jackon
annotations on the `Item` class. The risk we have just opened up is serving up passwords from the `User` entity. To
avoid that, we make this slight adjustment to `User`:

[source,java]
----
public class User {
	...
include::{baseDir}/src/main/java/com/greglturnquist/springagram/User.java[tag=user]
	...
----

Again, we are using the same `@JsonIgnore` annotation, this time on the password field to hide this bit of data.

WARNING: It is still possible to write a projection that would override and expose the password field. But that requires
deliberate forethough. Why can't Spring Data or Spring Security protect against this? We can't tell what is sensitive
and what's not. Imagine a domain with sensitive health care data restricted by regulation. The developer must properly
evaluate and code the restrictive semantics. This example should inspire with ideas on how to do it.

Bottom line: with a few annotations on key fields and interfaces, we have a nice declarative security model in place.
We didn't have to wire up special beans to define this policy. Instead, it's on the domain itself.

[[events]]
== Event-driven operations

A hallmark of modern applications is their dynamic reaction to things. For example, if someone else uploads a new image,
its expected to show up on your screen withouy clicking the refresh button. And on social media sites, there is an
assumption that after you login, content will be linked to your account. This application demonstrates both of these
features.

=== Automatically link uploaded pictures to the user's account

We already saw how <<security,items are links to users>> up above in the domain model. How do we implement this implicit assignment
of uploads to the logged-in user? Spring Data REST has several custom Spring Application Events. They are fired before
and after key events, like saving, deleting, and update resources. The following shows part of this app's event handler.

[source,java]
----
include::{baseDir}/src/main/java/com/greglturnquist/springagram/SpringDataRestEventHandler.java[tag=event-handler-one]

	...

include::{baseDir}/src/main/java/com/greglturnquist/springagram/SpringDataRestEventHandler.java[tag=event-handler-two]

	...
----

Key bits in this fragment:

* `@RepositoryEventHandler(Item.class)` annotation constraints this handler to `Item`.
* `@HandleBeforeCreate` annotation marks the `applyUserInformationUsingSecurityContext` method to be called before
an `Item` resource is created.
* Inside that handler method, Spring Security's `SecurityContextHolder` is used to fetch the current user's *username*.
* The `UserRepository` has a custom finder to turn *username* into an instance of `Item` which is used to populate the
item's *user* field before saving to the database.

This small bit of code makes the user experience perfect by automatically tagging items with ownership without encumbering
the user.

=== Sending out messages to the client for state changes

A classic pattern that's been around longer than the Gang-of-Four book is the subject-observer pattern. In essence,
whenever a key item updates, it sends out either a new copy of itself to all interested parties, or at least a message
saying "I've been updated!"

The same class you just saw has additional event handlers as shown below:

[source,java]
----
include::{baseDir}/src/main/java/com/greglturnquist/springagram/SpringDataRestEventHandler.java[tag=event-handler-one]

	...

include::{baseDir}/src/main/java/com/greglturnquist/springagram/SpringDataRestEventHandler.java[tag=event-handler-three]

	...

include::{baseDir}/src/main/java/com/greglturnquist/springagram/SpringDataRestEventHandler.java[tag=event-handler-four]
----

These extra bits of the same class listen for creation and deletion events, fetch the link for the corresponding item,
publishes it to a websocket. This provides an efficient pipeline of events to all clients who can decide whether or not
they are interested in updating their displays.

[[credits]]
== Credits

This document was brought to by https://github.com/spring-projects/spring-restdocs[Spring RestDocs], an
http://asciidoctor.org/[asciidoctor]-based solution to writing, testing, and documenting RESTful APIs without redundant information.
